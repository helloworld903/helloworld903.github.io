# java基础
1. **JDK和JRE有什么区别？**

JDK (Java Development Kit) , Java开发工具包<br />JRE (Java Runtime Environment) , Java运行环境<br /> JVM(java Virtual Machine), java 虚拟机  <br />**JDK中包含JRE，JDK中有一个名为jre的目录，里面包含两个文件夹bin和lib，bin就是JVM，lib就是JVM工作所需要的类库。**

2. **java程序是如何运行的？**

java->.class->jvm->装载->校验->解释->执行。<br />首先，Java代码被编译为字节码，也就是.class文件。随后，.class文件放入Java虚拟机。Java虚拟机使用类加载器加载.class文件。加载完成后会，会进行字节码校验。字节码校验通过后，JVM解释器会把字节码翻译为机器码交由操作系统执行。

3. **==和equals有什么区别？**

当使用"=="比较基本数据类型时，它会比较它们的值。但是对于引用类型（即对象），"=="比较的是它们在内存中的地址。"equals"是一个方法，用于比较对象的内容是否相等。该方法通常由类实现，以根据对象的特定属性来比较它们。

4. **java中final的作用？**

（1）修饰变量。将变量声明为final时，表示该变量的值在初始化后不能被修改。<br />（2）修饰方法。将方法声明为final时，表示该方法不能在子类中被重写或覆盖。<br />（3）修饰类。将类声明为final时，表示该类不能被其他类继承。

5. **java中static的作用？**

（1）静态变量。<br />（2）静态方法。<br />（3）静态代码快。<br />（4）静态内部类<br />静态成员在对象创建之前（类加载）就已经存在，因此，静态成员不能访问非静态的实例成员。

6. **String, StringBuffer, StringBuilder有什么区别?**

（1）可变性。String不可变，StringBuffer和StringBuilder可变。<br />（2）线程安全性。String不可变所以安全，StirngBuffer有同步机制，所以安全，StirngBuffer没有同步机制，不安全。<br />（3）性能。String由于不可变，每次对字符进行修改都会创建一个新的对象，资源消耗较大。StringBuffer和StringBuilder可变，不会频繁创建新的对象，性能上优于String。StringBuilder > StringBuffer > String。

6. **如何将字符串反转？**

将对象封装到stringBuilder中，调用reverse方法反转。

7. **String Pool**

String pool（字符串池）是Java中的一个字符串常量池，它是存储字符串常量的一种机制。在Java中，当我们创建一个字符串常量时，它们会被存储在字符串池中，以便在以后的使用中进行重复利用。

8. **String str="i"与String str=new String("i")一样吗？**

String str = "i"会首先在字符串池中查找相同内容的字符串，如果存在则共享对象，如果没有就创建一个再赋给变量。而String str = new String("i")会将对象分配到堆中，不管是否有相同内容的字符串，总是在堆内存中创建一个新的字符串对象。

9. **new String("a")+new String("b")会创建几个对象？**

（1）"a"：通过字符串字面量创建一个字符串常量对象，存储在字符串池中。<br />（2）new String("a")：通过使用new关键字显式地创建一个新的字符串对象，存储在堆内存中。<br />（3）"b"：通过字符串字面量创建一个字符串常量对象，存储在字符串池中。<br />（4）new String("b")：通过使用new关键字显式地创建一个新的字符串对象，存储在堆内存中。<br />（5）new StringBuilder()：创建一个新的StringBuilder对象，用于字符串拼接操作。<br />（6）new String("a") + new String("b")：通过StringBuilder的拼接操作生成一个新的字符串对象，存储在堆内存中。

10. **java访问权限**

（1）public（公共访问权限）：在任何地方都可以访问该类、成员或包。它具有最宽松的访问权限。<br />（2）protected（受保护访问权限）：只能在同一包内的类以及该类的子类中访问。在不同包内的非子类中无法直接访问。<br />（3）default（默认访问权限）：如果没有指定任何访问权限修饰符，则默认为默认访问权限。在同一包内可以访问，但在不同包内无法直接访问。<br />（4）private（私有访问权限）：只能在同一类内部访问，其他任何地方都无法直接访问。<br />![QQ截图20230701144417.png](https://cdn.nlark.com/yuque/0/2023/png/27308941/1688193867603-2145ade5-6676-489b-8df8-9b5463e84883.png#averageHue=%23f1f2f4&clientId=ucb3a4c9d-242a-4&from=drop&id=uf0214252&originHeight=173&originWidth=661&originalType=binary&ratio=1&rotation=0&showTitle=false&size=11102&status=done&style=none&taskId=ue8e4aeb8-c3e1-47f1-8d83-38a405994c8&title=)

11. **普通类和抽象类有哪些区别？**

抽象类可以有抽象方法，无法实例化。普通类不能有抽象方法，可以实例化。普通类继承另一个类时，不需要强制实现父类的方法，而抽象类继承时，子类必须实现抽象类中的所有抽象方法，除非子类自身也是抽象类。

12. **接口和抽象类有什么区别？**

（1）实现方式。接口是一种纯粹的抽象定义，它只包含方法声明而没有具体实现。抽象类是一个类的特殊类型，它可以包含方法的声明和实现。<br />（2）继承关系。类可以实现多个接口，但只能继承一个抽象类。<br />（3）成员变量。接口中只能定义常量成员变量，而抽象类可以定义各种类型的成员变量。接口的成员只能是 public 的，而抽象类的成员可以有多种访问权限。

13. **Object有哪些通用方法?**

（1）equals(Object obj)。用于比较对象是否相等。<br />（2）hashCode()。返回对象的哈希码值。<br />（3）toString()。返回对象的字符串表示。<br />（4）getClass()。返回对象的运行时类（Class对象）。<br />（5）clone()。创建并返回对象的一个副本（浅拷贝）。<br />（6）finalize()：垃圾回收器在回收对象之前调用的方法。<br />（7）notify()、notifyAll()、wait()。用于线程之间的通信和同步。

14. **java反射机制**

java的反射(reflection)机制是指程序在运行时动态地获取类的信息并操作类或对象，而无需在编译时知道类的具体信息。

15. **java IO**

（1）字节流。字节流以字节为单位进行读取和写入。字节流类通常以InputStream和OutputStream为后缀，用于处理二进制数据，如图像、音频、视频等。常见的实现类有FileInputStream、FileOutputStream等。<br />（2）字符流。字符流以字符为单位进行读取和写入，并且提供了字符编码和解码的功能。字符流类通常以Reader和Writer为后缀，用于处理文本数据。常见的实现类有FileReader、FileWriter等。<br />![QQ截图20230701153135.png](https://cdn.nlark.com/yuque/0/2023/png/27308941/1688196712190-a289e347-a941-4c28-8eba-5ff7583da9ec.png#averageHue=%23e7e7e7&clientId=u7804fa40-219f-4&from=drop&id=u7f29f05e&originHeight=220&originWidth=620&originalType=binary&ratio=1&rotation=0&showTitle=false&size=69042&status=done&style=none&taskId=ucd9e739d-4c8c-4be5-8d50-88fd2c49fb4&title=)

16. **BIO、NIO、AIO有什么区别？**

BIO（Blocking IO）是传统的IO模型，采用阻塞方式进行IO操作，每个IO请求都需要一个线程，在进行IO操作时，线程会被阻塞，直到数据准备好或操作完成。NIO（Non-blocking IO）引入了通道（Channel）和缓冲区（Buffer）的概念，支持非阻塞方式进行IO操作，可以使用单个线程处理多个连接，提高了系统的并发能力。AIO（Asynchronous IO)是异步IO模型，引入了异步回调机制，IO操作不会阻塞线程，当操作完成时会通知应用程序。

17. **throw和throws的区别？**

throw关键字用于手动抛出一个异常，将异常对象抛给调用者。throw语句通常出现在方法体内，用于表示出现了某种错误或异常情况，并将控制权交给上层调用者来处理。<br />throws关键字用于在方法声明中指定可能抛出的异常。throws用于向上层调用者声明该方法可能抛出的异常，以便调用者在使用该方法时进行异常处理。

18. **final、finally、finalize 有什么区别？**

final是一个修饰符，可以应用于类、方法和变量。<br />finally是一个关键字，用于定义在异常处理中的代码块。<br />finalize是一个方法，在Object类中定义，用于垃圾回收器在回收对象之前执行清理操作。

19. **java容器**

（1）Collection

   1. set

HashSet、TreeSet、LinkedHashSet

   2. list

ArrayList、LinkedList、Vector<br />（2）Map<br />HashMap、HashTable、TreeMap

20. **Collection与Collections的区别**

Collection是一个接口，他的实现类有SET和 List，collections是一个包装类，里面有 sort等方法，对集合中的元素进行排序搜索等操作。

21. **set和list的区别**

（1）List是有序集合，Set是无序集合。<br />（2）List允许重复元素，Set不允许重复元素。<br />（3）Set检索元素效率低下，删除和插入效率高，插入和删除不会引起元素位置改变，性能更好；List查找元素效率高，插入删除元素效率低，因为会引起其他元素位置改变。

22. **HashMap和HashTable有什么区别？**

（1）HashMap是线程不安全的，HashTable是线程安全的。<br />（2）HashMap允许键和值都为null，HashTable不允许。<br />（3）HashMap的默认容量是16（桶，每个桶可以存储一个或多个键值对），为2倍扩容，HashTable默认是11，为2倍+1扩容；<br />（4）由于HashTable在所有操作上都进行了同步处理，所以它的性能通常较HashMap低。

23. **ArrayList和LinkedList的区别？**

ArrayList是动态数组的数据结构实现，查找和遍历的效率较高； <br />LinkedList 是双向链表的数据结构，增加和删除的效率较高；

24. **容器方法的一些区别**

（1）offer()和add()区别。增加新项时，如果队列满了，add会抛出异常，offer返回false。<br />（2）poll()和remove()区别。poll()和remove()都是从队列中删除第一个元素，remove抛出异常，poll返回null。 <br />（3）peek()和element()区别。peek()和element()用于查询队列头部元素，为空时element抛出异常，peek返回null。

25. **那些集合是线程安全的？**

Vector、Stack、Hashtable、ConcurrentHashMap

26. **为什么HashMap每次扩容都是2倍？**

当HashMap中的元素数量接近或超过容量的75%时，会触发扩容操作，这是为了避免哈希冲突的发生频率过高，影响HashMap的性能。在扩容时，HashMap会创建一个新的数组，将所有的元素重新计算哈希值并重新分配到新的数组中。

27. **java常用异常类型**

IOException（输入/输出异常）<br />RuntimeException（运行时异常）<br />ClassCastException（类转换异常）<br />FileNotFoundException（文件未找到异常）<br />InterruptedException（中断异常）<br />NullPointerException（空指针异常）<br />ArrayIndexOutOfBoundsException（数组越界异常

28. **java创建线程的三种方式**

实现Runnable接口<br />实现Callable接口<br />继承Thread类;

29. **为什么说  synchronized 是非公平锁？**

当锁被释放后，任何一个线程都有机会竞争得到锁，这样做的目的是提高效率，但缺点是可能产生线程饥饿现象。

30. **为什么说synchronized 是一个悲观锁？乐观锁的实现原理又是什么？什么是CAS?它有什么特性?**

synchronized的并发策略是悲观的，不管是否产生竞争，任何数据的操作都必须加锁。乐观锁的核心是CAS，CAS包括内存值、预期值、新值，只有当内存值等于预期值时，才会将内存值修改为新值。

31. **乐观锁一定就是好的吗？**

乐观锁认为对一个对象的操作不会引发冲突，所以每次操作都不进行加锁，只是在最后提交更改时验证是否发生冲突，如果冲突则再试一遍，直至成功为止，这个尝试的过程称为自旋。乐观锁的优点是它减少了对共享资源的串行访问，从而提高了并发性能。由于不需要频繁地进行阻塞和解锁操作，因此可以降低系统的开销。<br />如果在系统中存在大量的并发操作，导致冲突的概率很高，那么乐观锁的效率可能会下降。因为乐观锁需要在提交阶段检测冲突，并且可能需要进行重试操作，这会增加系统的开销和延迟。同时，乐观锁只能保证在提交阶段检测到冲突时进行相应的处理，而无法在事务执行期间防止其他事务对共享资源的修改。如果在事务执行期间有其他事务修改了共享资源，可能会导致数据不一致的问题。

32. **不公平锁的实现原理**

当线程A执行完之后，要唤醒线程B是需要时间的，而且线程B醒来后还要再次竞争锁，所以如果在切换过程当中，来了一个线程C，那么线程C是有可能获取到锁的，如果C获取到了锁，B就只能继续休眠了。

33. **J.U.C AQS**

J.U.C（Java.util.concurrent）是Java中提供的用于并发编程的工具包，它提供了一系列的类和接口，用于解决多线程编程中的并发安全性、线程同步、线程池管理等问题。<br />AQS（AbstractQueuedSynchronizer）是J.U.C框架中的一个重要组件，它是一个用于构建锁和同步器的框架。AQS的核心思想是使用一个FIFO（先进先出）的等待队列来管理线程的竞争和等待，通过内置的状态变量来控制线程的获取和释放资源。使用AQS可以方便地实现各种同步器，如ReentrantLock、Semaphore、CountDownLatch等。

34. **如何实现线程安全**

（1）使用同步锁（Synchronization）<br />（2）使用并发集合（Concurrent Collections）<br />（3）使用原子类（Atomic Classes）<br />（4）使用锁机制（Locking)<br />（5）使用线程安全的类库或框架

35. **java线程池是如何实现的**

Java线程池是一种用于管理和复用线程的机制，它可以提高多线程程序的性能和效率。<br />Java线程池的主要组成部分包括：<br />（1）线程池管理器（ThreadPoolExecutor）<br />（2）工作队列（BlockingQueue）<br />（3）线程工厂（ThreadFactory）<br />Java线程池的工作流程如下：<br />（1）初始化线程池管理器，指定线程池的配置参数，如核心线程数、最大线程数、工作队列等。<br />（2）提交任务给线程池，线程池将任务存储在工作队列中。<br />（3）线程池中的空闲线程从工作队列中获取任务进行执行。<br />（4）如果线程池中的线程数量达到核心线程数，则新提交的任务将被放入工作队列中等待执行。<br />（5）如果工作队列已满，并且线程池中的线程数量未达到最大线程数，则创建新的线程来执行任务。<br />（6）当线程池中的线程数量超过核心线程数，并且空闲时间达到一定阈值时，多余的线程将被终止并回收。

36. **volatile关键字**

volatile 是 Java 中的一个关键字，用于声明变量。它主要有以下两个作用：<br />（1）保证可见性：volatile 关键字保证了变量的可见性，即当一个线程修改了被 volatile 修饰的变量的值时，其他线程能够立即看到最新的值，而不是使用自己线程缓存中的旧值。<br />（2）禁止指令重排序：在多线程环境下，JVM 为了提高性能可能会对指令进行重排序，但是这种重排序可能会导致多线程程序出现意想不到的错误。

37. **原子操作**

原子操作是指在执行过程中不会被其他线程干扰或中断的操作。原子操作要么完全执行成功，要么完全不执行，不会出现部分执行的情况。原子操作可以保证数据的一致性和线程的安全性。

38. **java内存区域**

jdk 1.8以前：<br />![QQ截图20230703153903.png](https://cdn.nlark.com/yuque/0/2023/png/27308941/1688369962849-f61b8e58-8e90-4d8f-892c-16bafbd1d91c.png#averageHue=%23dcdfe7&clientId=u7804fa40-219f-4&from=drop&id=u430d0d83&originHeight=481&originWidth=520&originalType=binary&ratio=1&rotation=0&showTitle=false&size=113455&status=done&style=none&taskId=uc53f314c-c872-4471-a5d9-7795d000889&title=)<br />（1）运行时数据区域<br />a. 堆。Java堆是Java虚拟机管理的最大的一块内存区域，用于存储对象实例和数组。<br />b. 方法区。方法区用于存储类的信息、静态变量、常量池、即时编译器编译后的代码等数据。<br />c. 常量池。运行时常量池是方法区的一部分，用于存放编译期生成的各种字面量和符号引用

d. 程序计数器。程序计数器是一块较小的内存区域，它存储当前线程执行的字节码指令的地址。<br />e. java虚拟机栈。每个线程在执行Java方法时都会创建一个栈帧，栈帧用于存储方法的局部变量、操作数栈、动态链接、方法出口等信息。<br />f. 本地方法栈。本地方法栈类似于Java虚拟机栈，但是它为本地方法（Native Method）服务，即使用其他语言（如C、C++）编写的方法。<br />（2）直接内存。通过使用ByteBuffer等类库来直接分配操作系统内存的一块区域<br />jdk 1.8以后：<br />![QQ截图20230703155417.png](https://cdn.nlark.com/yuque/0/2023/png/27308941/1688370871555-063313ba-5357-4536-af50-55c1c315c949.png#averageHue=%23e1e0df&clientId=u7804fa40-219f-4&from=drop&id=u66391957&originHeight=450&originWidth=529&originalType=binary&ratio=1&rotation=0&showTitle=false&size=102327&status=done&style=none&taskId=ua7398e3b-95a3-4a8a-8d7b-acbef166906&title=)

39. **为什么要将永久代(PermGen)的实现从方法区替换为元空间(MetaSpace)呢?**

因为永久代的空间有限，在大量使用字符串的场景下会导致OutOfMemoryError错误。

40. **java gc原理（Garbage Collection，垃圾回收）**

Java的垃圾回收（Garbage Collection，简称GC）是自动内存管理的一种机制，它负责在程序运行时自动回收不再使用的对象所占用的内存空间，释放资源并提供给其他对象使用。<br />下是Java垃圾回收算法：<br />（1）标记-清除算法。在标记阶段，会对可回收对象进行标记；在清除阶段，对标记的对象进行清除，并取消标记。<br />（2）复制算法。将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。<br />（3）标记-整理算法。标记阶段，标记可回收对象；整理阶段，所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。<br />（4）分代收集算法。根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。

41. **如何判断对象是否可以回收？**

（1）引用计数法。为对象添加一个引用计数器，当对象增加一个引用时计数器加1，引用失效时计数器减1，引用计数为0的对象可被回收。<br />（2）可达性分析。该算法从一组称为"GC Roots"的根对象开始，通过遍历对象引用链，标记所有与根对象直接或间接相连的对象为可达对象，未标记的对象即为不可达对象。<br />（3）方法区回收。<br />（4）finalize()。

42. **引用类型**

（1）强引用。（new）被强引用关联的对象不会被回收。<br />（2）软引用。当系统内存不足时，垃圾回收器会根据一定的策略回收软引用指向的对象。<br />（3）弱引用。弱引用的生命周期较短，只要进行垃圾回收就会被回收。<br />（4）虚引用。虚引用与对象本身的生命周期没有直接关系，它的主要作用是在对象被回收前收到系统的通知。

43. **垃圾收集器**

（1）GMS收集器。初始标记、并发标记、重新标记（多线程、串行）、并发清除。停顿>不停顿>停顿->不停顿。不并发->并发->不并发->并发。只有重新标记阶段是多线程。<br />（2）G1收集器。初始标记、并发标记、最终标记、筛选回收。<br />（3）Serial收集器。该收集器是最古老和最简单的收集器，以单线程方式进行垃圾回收<br />（4）Parallel收集器。该收集器也称为吞吐量优先收集器，使用多线程方式进行垃圾回收，以最大化吞吐量。

44. **类的生命周期**

![QQ截图20230703170621.png](https://cdn.nlark.com/yuque/0/2023/png/27308941/1688375193532-8591a94f-d525-4501-998f-f571e6b8dd79.png#averageHue=%23f7f7f7&clientId=u7804fa40-219f-4&from=drop&id=ub29036d1&originHeight=151&originWidth=691&originalType=binary&ratio=1&rotation=0&showTitle=false&size=33073&status=done&style=none&taskId=u27a0b540-97c2-45cd-990c-9fb7c4c981a&title=)<br />（1）加载。将类的字节码数据加载到虚拟机中。<br />（2）验证。验证类的字节码是否符合虚拟机规范，包括语法、语义、安全性等方面的检查。<br />（3）准备。为类的静态变量分配内存，并初始化为默认值。<br />（4）解析。将符号引用转换为直接引用，即将类、字段、方法的符号引用转换为对应的直接内存指针。<br />（5）初始化。虚拟机会执行类构造器 <clinit> ()的代码，对静态变量进行初始化，执行静态代码块等操作。<br />（6）使用。类被加载后，通过创建对象、调用方法等方式进行实际的使用。<br />（7）卸载。虚拟机将不再需要的类从内存中卸载。

45. **jvm参数如何配置？**

-Xmx最大分配的堆大小<br />-Xms初始化的堆大小<br />设置这两个成相同大小，避免在程序运行时堆不够用时要动态扩展，就节省这部分性能，并且尽可能的使田最大的堆大小，可以减少GC时间<br />等等。

46. **java对象的创建过程**

（1）加载类。在对象创建之前，首先需要将对象所属的类加载到内存中。类加载的过程包括加载、验证、准备、解析和初始化等步骤。<br />（2）分配内存。在内存中为对象分配一块连续的内存空间。内存分配的方式有多种，包括在堆上分配、栈上分配或者在方法区中分配（针对字符串常量池）。<br />（3）初始化零值。在内存分配完成后，虚拟机会将对象的实例变量初始化为默认的零值，例如数值类型的变量初始化为0，引用类型的变量初始化为null。<br />（4）设置对象头。对象在内存中的布局中包含一个对象头，用于存储对象的元数据信息，如对象的哈希码、锁状态等。<br />（5）执行构造函数。在分配内存、初始化零值和设置对象头之后，会调用对象的构造函数来对对象进行初始化。构造函数会对对象的实例变量进行赋值，进行必要的初始化操作。<br />（6）返回对象的引用。对象初始化完成后，会返回一个指向对象的引用，通过该引用可以访问和操作对象的成员

47. **方法在虚拟机栈中的执行过程**

（1）方法调用。当一个方法被调用时，虚拟机会创建一个新的栈帧（Stack Frame）并将其推入虚拟机栈的顶部。栈帧包含了方法的局部变量表、操作数栈、动态链接、返回地址和一些额外的附加信息。<br />（2）分配局部变量表和操作数栈。在创建栈帧后，虚拟机会根据方法的签名和局部变量的定义来分配局部变量表和操作数栈的空间。局部变量表用于存储方法的参数和局部变量，操作数栈用于存储方法执行过程中的操作数。<br />（3）方法执行。接下来，虚拟机会按照方法的字节码指令一条一条地执行方法体中的代码。这包括加载、存储、计算和控制流等操作。虚拟机通过解释器或即时编译器（JIT）来解释和执行字节码指令。<br />（4）方法返回。当方法执行完成或遇到返回指令时，虚拟机会将栈帧从虚拟机栈中弹出，并将控制权返回给调用该方法的地方。返回的过程包括恢复调用方法的栈帧、传递返回值（如果有的话）以及恢复调用方法的执行状态。

48. **JVM的运行时数据区，分成堆和栈有什么好处?只有栈没有堆会怎样?**

（1）内存管理。将内存划分为堆和栈可以更好地管理和分配内存资源。堆用于存储动态分配的对象，而栈用于管理方法的调用和局部变量的存储。通过区分堆和栈，可以实现不同的内存管理策略，例如堆的自动内存管理和垃圾回收，以及栈的快速分配和释放。<br />（2）对象生命周期管理。堆用于存储对象，可以动态地分配和释放内存。对象在堆上分配，可以在需要时保持存活，并在不再被引用时被垃圾收集器回收。而栈上的局部变量在方法执行结束后自动释放，不需要额外的垃圾回收操作。<br />（3）线程安全。栈是线程私有的，每个线程都有自己的栈，栈中存储了线程独有的方法调用和局部变量。这样可以避免多线程访问同一个栈帧的冲突，提高线程的安全性和并发性。<br />如果只有栈而没有堆，会导致以下问题：<br />（1）无法动态分配内存。栈是一个固定大小的数据结构，用于管理方法调用和局部变量。栈的大小是在编译时确定的，无法根据程序运行时的需求进行动态调整。如果只有栈而没有堆，无法进行动态分配和释放内存，限制了程序的灵活性和扩展性。<br />（2）无法存储动态分配的对象。栈上的局部变量只能存储基本类型和引用类型的引用，无法存储动态创建的对象。如果只有栈而没有堆，无法创建和管理对象，限制了程序的功能和复杂性。

49. **常量什么时候放入常量池？**

编译时、运行时

50. **对象一定是在堆里吗？**

不一定。一些局部变量会保存在栈上。（在Java中，大多数对象都是在堆内存中分配的。堆是用于存储动态分配的对象的区域，它是Java虚拟机管理的内存区域之一。）

51. **零拷贝**

传统io：<br />![QQ截图20230703194917.png](https://cdn.nlark.com/yuque/0/2023/png/27308941/1688384974467-e883dc35-1c54-49e6-b090-631eefde1b23.png#averageHue=%23f9f9f9&clientId=u7804fa40-219f-4&from=drop&id=uaefecbf2&originHeight=473&originWidth=718&originalType=binary&ratio=1&rotation=0&showTitle=false&size=48639&status=done&style=none&taskId=u56a7ee23-490e-452d-ae3a-f61c21c46c4&title=)<br />零拷贝：<br />![微信截图_20230703195052.png](https://cdn.nlark.com/yuque/0/2023/png/27308941/1688385073537-098cd634-d5c8-40c4-ab4b-e80c0761c7e8.png#averageHue=%23f7f7f7&clientId=u7804fa40-219f-4&from=drop&id=uc19937ff&originHeight=402&originWidth=497&originalType=binary&ratio=1&rotation=0&showTitle=false&size=35816&status=done&style=none&taskId=uf73dba93-65f9-4e1d-81bc-6f27f4b0dec&title=)<br />内存映射技术将文件或设备的某个区域映射到进程的地址空间中，使得应用程序可以直接访问这些内存区域。这样就可以避免数据在不同缓冲区之间的复制，提高内存操作的效率。

52. **介绍下select和epoll以及它们的区别和各自的使用场景**

select是Unix系统早期提供的一种I/O多路复用机制。select通过将一组文件描述符传递给系统调用，然后阻塞等待，直到其中任何一个文件描述符准备好进行I/O操作时返回。select有一个缺点是，每次调用都需要将所有的文件描述符集合传递给内核，包括未就绪的文件描述符，这会导致效率低下，尤其在文件描述符数量较多时。<br />epoll是Linux系统引入的高性能I/O多路复用机制。epoll使用了一种基于事件驱动的方式来处理I/O操作，相比select有更好的性能和扩展性epoll通过将文件描述符注册到内核维护的事件表中，并使用回调函数来处理就绪的事件。在事件就绪时，内核会将就绪的文件描述符添加到一个就绪队列中，应用程序可以直接访问该队列以处理事件。<br />select适用于较早的Unix系统和较小规模的文件描述符数量。<br />epoll适用于Linux系统，特别是在高并发的网络编程中，对于大规模的文件描述符数量更加高效。

53. **什么是面向对象编程？**

在Java中，面向对象编程是一种编程范式，它以对象作为程序的基本单元，通过对象之间的交互来实现系统的设计和开发。在面向对象编程中，Java程序由一组相互协作的对象组成。每个对象都具有自己的属性和方法。对象之间通过消息传递来进行交互，通过封装、继承和多态等机制来实现代码的重用和扩展。

54. **sychronized和ReentrantLock区别是什么？**

（1）ReentrantLock 使用起来比较灵活，但是必须有释放锁的配合动作。（2）ReentrantLock 必须手动获取与释放锁，而 synchronized 不需要手动释放和开启锁。<br />（3）ReentrantLock 只适用于代码块锁，而 synchronized 可以修饰类、方法、变量等。
# Linux 

1. <br />
# Spring

1. **什么是spring**

Spring是一个开源的Java框架，旨在简化企业级应用程序的开发。它提供了一套全面的解决方案，涵盖了IoC容器、AOP、声明式事务管理、集成支持等核心特性。Spring的设计理念包括轻量级、非侵入性和松耦合，它通过IoC容器实现对象的创建、配置和管理，通过依赖注入实现对象之间的解耦。同时，Spring提供了对AOP的全面支持，将横切关注点从核心业务逻辑中分离出来，提高了代码的模块化和可维护性。Spring还提供了声明式事务管理、集成支持和丰富的测试支持，使开发人员能够轻松集成各种技术，编写可测试和可靠的应用程序。

2. **spring AOP实现原理**

AOP（Aspect-Oriented Programming，面向切面编程）是一种编程范式，它的目的是通过在程序中添加横切关注点（Cross-cutting Concerns），将与核心业务逻辑无关的功能模块化，从而提高代码的模块性、可维护性和重用性。<br />AOP的实现是基于动态代理技术和字节码操作。在运行时，AOP框架通过动态生成代理对象或在编译期间修改字节码的方式，将横切关注点插入到目标代码中。<br />以下是AOP实现的核心概念和原理：<br />切面、连接点、切点、通知、织入。

3. **sprint IOC实现原理**

Spring IOC（Inversion of Control，反转控制）通过控制反转的方式实现了对象的依赖注入和管理。lOC的思想就是两方之间不互相依赖，由第三方容器来管理相关资源，由此更好进行对象之间依赖关系的管理以及进行单元测试。

4. **bean的作用域**

（1）singleton（默认）。单例作用域表示在整个应用程序中只存在一个Bean实例，Spring容器会在启动时创建该Bean，并在整个应用程序生命周期内共享该实例。<br />（2）prototype。原型作用域表示每次请求获取Bean时，都会创建一个新的实例<br />（3）request。请求作用域仅在Web应用程序中有效。<br />（4）session。会话作用域也仅在Web应用程序中有效。<br />（5）global session。全局会话作用域与会话作用域类似，但仅在使用基于portlet的Web应用程序时才有效。

5. **bean的生命周期**

（1）实例化。Spring通过反射或工厂方法创建Bean的实例。<br />（2）属性赋值。Spring将Bean的属性值设置到相应的属性中。<br />（3）初始化前。Spring会调用Bean的初始化方法。<br />（4）初始化后。Spring会执行Bean的后初始化操作。<br />（4）销毁。Spring会调用Bean的销毁方法

6. **bean的注入方式**

（1）xml注入<br />set方式注入<property>、构造方法注入<constructor-arg>
```xml
<bean id="userService" class="com.example.UserServiceImpl" />
```
（2）注解方式注入<br />@Autowired、@Inject

7. **bean的初始化流程**

实例化->属性注入（->Aware接口回调）->BeanPostProcessor前置处理->初始化方法调用->BeanPostProcessor后置处理->Bean的使用

8. **spring的启动流程**

加载配置文件->创建IOC容器->实例化Bean->依赖注入->执行初始化方法->应用程序启动->提供服务

9. **spring如何解决循环依赖**

循环依赖是指多个对象之间形成了相互依赖的关系，形成了一个闭环的依赖链。<br />Spring通过使用三级缓存解决循环依赖的问题。分别是，单例对象缓存、早期对象缓存、原始对象缓存。<br />当创建一个Bean时，Spring首先会检查一级缓存（单例对象缓存）中是否已经存在该Bean的完全初始化的实例。如果存在，则直接返回该实例，解决了简单的循环依赖情况。如果一级缓存中不存在该Bean的实例，那么Spring会检查二级缓存（早期对象缓存）。如果二级缓存中存在该Bean的实例，说明该Bean正在创建中，但尚未完成初始化。此时，Spring会返回该早期对象，从而解决了循环依赖中的相互引用问题。如果二级缓存中也不存在该Bean的实例，那么Spring会创建一个原始对象（工厂对象）并放入三级缓存（原始对象缓存）中。这个原始对象实际上是一个未完全初始化的Bean实例，它只具备被其他Bean引用的能力，但尚未完成自身的初始化过程。在创建原始对象时，Spring会递归地解析并创建该Bean所依赖的其他Bean，并将它们注入到原始对象中。如果其他Bean存在循环依赖，Spring会在创建过程中通过三级缓存获取到尚未完全初始化的原始对象，从而解决循环依赖中的相互引用问题。最后，当所有的Bean都创建完成并完成初始化后，它们会被移出三级缓存，并放入一级缓存中。这样，在后续的Bean获取或依赖注入过程中，Spring会直接从一级缓存中获取到已经完全初始化的Bean实例。

10. **什么是懒加载？spring如何实现懒加载？**

懒加载（Lazy Loading）是一种延迟加载的机制，在需要使用某个资源或对象时才进行加载，而不是在初始化阶段就加载。<br />两种实现方法：<br />（1）使用XML配置文件的lazy-init属性<br />（2）使用@Lazy注解

11. **Autowired和Resource、Inject关键字的区别**

@Autowired:：自动装配依赖，通过类型进行自动注入。<br />@Resource：提供了更加细粒度的控制。它可以通过name属性指定Bean的名称，或者通过type属性指定Bean的类型进行注入<br />@Inject是Java标准的依赖注入注解，它也会根据类型进行自动装配，并可以结合@Qualifier注解指定具体的Bean

12. **spring中有哪些常用注解**

（1）@Component: 将类标记为一个组件，Spring会自动扫描并将其纳入容器管理。<br />（2）@Controller: 标记类为一个控制器（Controller），用于处理用户请求。<br />（3）@Service: 标记类为一个服务（Service），用于处理业务逻辑。<br />（4）@Repository: 标记类为一个存储库（Repository），用于访问数据库或其他数据源。<br />（5）@Autowired: 自动装配依赖，通过类型进行自动注入。<br />（6）@Value: 注入配置属性值。<br />（7）@RequestMapping: 定义请求映射，用于将HTTP请求映射到处理方法。<br />等等
# Spring MVC

1. **什么是spring mvc?**

Spring MVC是Spring框架中的一个模块，用于构建基于MVC（模型-视图-控制器）模式的Web应用程序。它提供了一套机制来处理HTTP请求、响应以及视图渲染，并提供了处理表单提交、数据验证、拦截器、国际化等功能。

2. **spring mvc和spring区别**

Spring是一个全面的应用程序开发框架，提供了诸多功能和特性，如依赖注入、面向切面编程、事务管理、数据访问、安全性等。它为开发人员提供了一个灵活、可扩展和可维护的编程模型，用于构建企业级Java应用程序。<br />Spring MVC是Spring框架中的一个模块，用于构建基于MVC（模型-视图-控制器）模式的Web应用程序。它提供了一套机制来处理HTTP请求、响应以及视图渲染，并提供了处理表单提交、数据验证、拦截器、国际化等功能。Spring MVC通过DispatcherServlet作为前端控制器，将请求分发给相应的处理器(Controller)，处理器处理请求并返回模型数据和视图，最后由视图解析器将视图渲染并返回给客户端。

3. **spring mvc工作流程**

（1）客户端发送HTTP请求到DispatcherServlet（前端控制器）。<br />（2）DispatcherServlet根据请求的URL选择合适的HandlerMapping（处理器映射器）来确定具体的处理器(Controller)。<br />（3）HandlerMapping将请求映射到一个或多个处理器(Controller)。<br />（4）DispatcherServlet调用处理器(Controller)来处理请求，并传递相应的模型数据。<br />（5）处理器(Controller)执行业务逻辑，可能会通过调用业务逻辑层的服务类来获取或处理数据，并返回一个ModelAndView对象。<br />（6）DispatcherServlet根据返回的ModelAndView对象，通过ViewResolver（视图解析器）来解析对应的视图(View)。<br />（7）ViewResolver根据视图名称解析为具体的视图对象。<br />（9）DispatcherServlet将模型数据传递给视图(View)，并让视图渲染生成最终的响应结果。<br />（10）DispatcherServlet将响应结果返回给客户端。<br />![QQ截图20230704161256.png](https://cdn.nlark.com/yuque/0/2023/png/27308941/1688458448491-0d882452-c7c3-41c4-a9b6-553e426c0411.png#averageHue=%23f7f7f7&clientId=u1c01d540-cef2-4&from=drop&id=u95a78d19&originHeight=677&originWidth=1190&originalType=binary&ratio=1&rotation=0&showTitle=false&size=136584&status=done&style=none&taskId=u91e9f491-d7f7-4138-993f-fd5ad748431&title=)
# Spring Boot

1. **什么是spring boot?**

Spring Boot是一个用于快速开发基于Spring框架的应用程序的开源框架。它简化了Spring应用程序的初始化和配置过程，使开发人员能够更专注于业务逻辑的实现。Spring Boot提供了一种约定优于配置的方式，通过自动配置和默认值，减少了繁琐的配置工作。它内置了一个嵌入式的Servlet容器（如Tomcat、Jetty或Undertow），并提供了一组对常见功能的自动配置，例如数据库访问、安全性、日志记录等。它减少了开发人员的配置工作，提供了开箱即用的功能和默认值，使得开发者能够更专注于业务逻辑的实现，从而加快了应用程序的开发速度和部署效率。

2. **spring、spring mvc、spring boot**

Spring是一个开源的Java开发框架，提供了丰富的功能和组件，用于开发企业级应用程序。<br />Spring MVC是Spring框架的一部分，是基于Servlet API的Web框架，用于开发Web应用程序。它提供了一种MVC（Model-View-Controller）的架构模式，通过DispatcherServlet、HandlerMapping、Controller和View等组件来处理和响应HTTP请求。<br />Spring Boot是基于Spring框架的一个子项目，它简化了Spring应用程序的初始化和配置过程。Spring Boot提供了约定优于配置的方式，通过自动配置和默认值，减少了繁琐的配置工作。它内置了一个嵌入式的Servlet容器，并提供了一组对常见功能的自动配置，如数据库访问、安全性、日志记录等。
# 计算机网络

1. **七层网络模型及其协议**

（1）物理层（Physical Layer）。负责传输比特流，物理层的协议包括Ethernet、RS-232、V.35等。<br />（2）数据链路层（Data Link Layer）。负责在直连的节点之间传输数据帧，数据链路层的协议包括以太网（Ethernet）、Wi-Fi、PPP（Point-to-Point Protocol）等。<br />（3）网络层（Network Layer）。负责通过网络传输数据包，网络层的协议包括IP（Internet Protocol）、ICMP（Internet Control Message Protocol）、ARP（Address Resolution Protocol）等。<br />（4）传输层（Transport Layer）。负责在端到端的通信中提供可靠的数据传输，传输层的协议包括TCP（Transmission Control Protocol）、UDP（User Datagram Protocol）等。<br />（5）会话层（Session Layer）。负责建立、管理和终止会话连接，会话层的协议包括TLS（Transport Layer Security）、SSH（Secure Shell）等。<br />（6）表示层（Presentation Layer）。负责数据的格式转换、加密和解密等，表示层的协议包括ASCII（American Standard Code for Information Interchange）、JPEG（Joint Photographic Experts Group）等。<br />（7）应用层（Application Layer）：提供网络应用程序的接口，应用层的协议包括HTTP（Hypertext Transfer Protocol）、FTP（File Transfer Protocol）、SMTP（Simple Mail Transfer Protocol）等<br />![QQ截图20230704162244.png](https://cdn.nlark.com/yuque/0/2023/png/27308941/1688458994088-bc478062-ebf9-4c67-a7f4-e5708d358151.png#averageHue=%23f3f3f2&clientId=u1c01d540-cef2-4&from=drop&id=u4985e1ba&originHeight=224&originWidth=789&originalType=binary&ratio=1&rotation=0&showTitle=false&size=62759&status=done&style=none&taskId=u810708c9-71ea-4eb8-8d65-ea9a125bddd&title=)

2. **三次握手，四次挥手**

三次握手：<br />![QQ截图20230704164228.png](https://cdn.nlark.com/yuque/0/2023/png/27308941/1688460166697-01a856ec-58a0-4984-8f1b-03332f24b94e.png#averageHue=%23faf5f2&clientId=u1c01d540-cef2-4&from=drop&id=u8b5cde24&originHeight=514&originWidth=897&originalType=binary&ratio=1&rotation=0&showTitle=false&size=109279&status=done&style=none&taskId=u2f663b03-52ae-45a2-be6a-5d1132fc137&title=)<br />四次挥手：<br />![QQ截图20230704164300.png](https://cdn.nlark.com/yuque/0/2023/png/27308941/1688460190582-a66bbdf4-2496-4e5a-944b-5a5452f513cb.png#averageHue=%23f8f5f0&clientId=u1c01d540-cef2-4&from=drop&id=ud5eff4c3&originHeight=504&originWidth=857&originalType=binary&ratio=1&rotation=0&showTitle=false&size=131278&status=done&style=none&taskId=ub002ffe1-99ee-4d25-b35f-dd375d6a295&title=)

3. **为什么要进行三次握手？**

进行三次握手（Three-Way Handshake）是为了建立一个可靠的、双向的数据传输通道，确保通信双方都能够正常发送和接收数据。<br />（1）防止已过期的连接请求到达服务器，让服务器再次打开连接<br />客户端发送的连接请求如果在网络中滞留，超时以后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器发送的对滞留连接请求的连接确认，因此就不会再次打开连接。<br />（2）防止发生死锁<br />假定客户端给服务端发送一个连接请求报文，服务端收到了这个报文并发送了确认应答报文。按照两次握手的协定，服务端认为连接已经成功地建立了，可以开始发送数据报文。可是，客户端在服务端的应答报文在传输中被丢失的情况下，不知道服务端建立什么样的序列号，客户端甚至怀疑服务端是否收到自己的连接请求报文。在这种情况下，客户端认为连接还未建立成功，将忽略服务端发来的任何数据报文(因为报文的确认号不连续了），只等待连接确认应答报文。而服务端在发出的数据报文超时后，重复发送同样的报文。这样就形成了死锁。

4. **第三次握手失败了怎么办？服务端和客户端会做些什么？**

服务端：如果服务端发送了确认消息但未收到客户端的确认消息，服务端会在一定的超时时间后重新发送第二次握手的确认消息。服务端会根据具体的实现方式和超时策略进行重传，通常会进行多次重传尝试。<br />客户端：如果客户端发送了确认消息但未收到服务端的确认消息，客户端会在一定的超时时间后重新发送第三次握手的确认消息。客户端会根据具体的实现方式和超时策略进行重传，通常会进行多次重传尝试。<br />连接中断：如果经过多次重传后仍然无法完成第三次握手，双方会认为连接建立失败，会中断连接尝试，关闭连接。这样可以释放资源并允许后续的连接尝试。

5. **为什么连接的时候是三次握手，关闭的时候却是四次挥手？**

因为四次握手多了CLOSE_WAIT 状态，要等待服务端向客户端传输完数据，不能马上发送请求关闭连接的报文到客户端，而在三次握手则服务端在接收到了客户端的请求连接报文以后，服务端可以马上发送请求连接的报文，所以这就多了这一次握手。

6. **如果已经建立了连接,但是客户端突然出现故障了怎么办?**

TCP设有一个保活计时器，服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若客户端如果出现故障，两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。

7. **为什么TIME_WAIT 状态需要经过2MSL(报文段最大生存时间)才能进入到CLOSE状态?**

确保客户端向服务端发送的最后一个确认报文能够到达。如果服务端没收到客户端发送来的确认报文，那么就会重新发送连接释放请求报文。所谓的 2MSL是两倍的MSL(Maximum SegmentLifetime)。MSL 指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client 都没有再次收到FIN，那么Client 推断ACK已经被成功接收，则结束TCP连接。

8. **TCP如何实现可靠性？**

（1）序列号和确认机制。每个TCP报文段都有一个序列号，用于按序传输数据。接收方会发送确认消息，确认已经接收到的数据。如果发送方在一定时间内没有收到确认消息，就会重新发送数据。<br />（2）超时重传。发送方会设置一个定时器，等待接收方发送确认消息。如果在定时器超时之前没有收到确认消息，发送方会重新发送数据。<br />（3）流量控制。TCP使用滑动窗口机制来控制发送方和接收方之间的数据流量。接收方可以告知发送方它的接收窗口大小，发送方会根据接收窗口大小调整发送数据的速率，避免发送过多的数据导致接收方无法及时处理。<br />（4）拥塞控制。TCP通过拥塞控制算法来避免网络拥塞。当网络出现拥塞时，发送方会减小发送速率，以避免进一步加剧网络拥塞。常用的拥塞控制算法包括慢启动、拥塞避免和快速恢复等。<br />（5）确认丢失重传。如果发送方发送的数据包没有被接收方正确确认，发送方会进行重传，以确保数据的可靠传输。

9. **UDP不可靠为什么还要用它？**

相比于TCP，UDP具有较低的延迟。TCP为了实现可靠性和流量控制等功能，需要进行三次握手、拥塞控制等操作，这些额外的处理会导致一定的延迟。而UDP不具备这些机制，直接将数据包发送出去，因此在对延迟要求较高的实时应用场景中，如实时音视频传输、在线游戏等，使用UDP可以更好地满足要求。另一方面，UDP的报文和实现相对简单，占用的系统资源较少，适用于资源有限的环境。

10. **UDP如何实现可靠传输？**

确认机制、超时重传、滑动窗口。

11. **TCP和UDP的区别？**

TCP面向连接，UDP无连接。<br />TCP可靠传输，UDP不可靠传输。<br />TCP延时高，UDP延时低。<br />TCP所需资源多，UDP所需资源少。<br />TCP首部字节多，UPD首部字节少。<br />适用场景不同。

12. **什么是粘包问题？**

粘包问题（Packet Sticking Problem）是在网络通信中经常遇到的一个现象。它指的是发送方在发送数据时，由于数据传输的特性或者其他原因，导致接收方在接收数据时无法正确地区分出每个数据包的边界，从而将多个数据包黏在一起形成一个大的数据块，称为粘包。

13. **IPV4和IPV6的区别**

1.地址长度: v4具有32位地址长度;v6具有128位地址长度<br />2.地址的表示方法: v4以点分十进制。V6是以八组四位十六进制数表示<br />3.路由表和路由协议：IPv4的路由表规模庞大，需要使用复杂的路由协议来管理和维护路由信息。而IPv6的地址空间较大，使得路由表规模较小，简化了路由协议和路由表的管理。<br />4.v6引入新的特性，如多播支持，无状态地址自动配置等。

14. **网络地址转换**

网络地址转换（Network Address Translation，简称NAT）是一种网络通信技术，用于将私有网络中的IP地址转换为公共网络可路由的IP地址，以实现私有网络与公共网络之间的通信。

15. **什么是ARP欺骗？**

在局域网中，主机之间通信通常使用MAC地址（物理地址）来定位目标主机。通信主机在不知道目标主机ip时，会在局域网中发送ARP广播，这时，攻击者发送伪造的ARP响应包，将自己伪装成目标主机，以此获取发送给目标主机的数据。

16. **cookie和session**

Cookie是存储在客户端的浏览器中的小型数据文件，用于跟踪用户身份认证和记录用户偏好设置。<br />Session是服务器端维护的与用户会话相关的数据，用于存储和管理会话数据。<br />Cookie存储在客户端，Session存储在服务器端。

17. **htttp和https的区别**

Http主要有以下安全性问题:<br />（1）数据传输时，使用明文进行通信，内容可能会被监听;<br />（2）数据传输时，不验证通信方的身份，通信方的身份有可能遭遇伪装；<br />（3）数据传输后，无法证明报文的完整性，报文有可能遭篡改。<br />HTTPS是在 HTTP的基础上增加了SSL或TLS安全协议，让 HTTP先和SSL (Secure Sockets Layer）通信，再由SSL和TCP 通信，也就是说HTTPS使用了隧道进行通信。SSL和TSL这两个协议可以加密处理数据〈采用混合加密技术）防止数据被监听、验证通信方身份(通过数字证书认证通信方是自己的服务器）以及数据完整性保护（防止传输的内容被中间人冒充或者篡改)。

18. **什么是对称加密？**

在对称加密中，发送方和接收方使用相同的密钥对数据进行加密和解密。

19. **什么是非对称加密？**

在非对称加密中，有两个密钥，一个是公钥（public key），另一个是私钥（private key）。公钥用于加密数据，而私钥用于解密数据。

20. **dns查询过程**

首先通过URL找到主机名。比如 www.baidu.com，根据这个去浏览器缓存里面找，如果没有就去本机的 host 的文件找,在没有就去访问本地域名服务器,询问能不能找到这个主机IP地址的缓存。再没有就通过迭代的方法，找根域名服务器，顶级、权威，最后返回一个ip地址给DNS应用。当发送一个DNS请求的时候，如果本地域名服务器中没有的话，本地域名服务器就会代理的作用将请求转发到DNS 服务器层次结构中。

21. **大量time_wait造成的影响**

服务器资源浪费。<br />内存资源占用。<br />连接建立延迟。

22. **Http协议1.0和1.1、2.0的区别**

http/1.0 无连接（浏览器的每次请求都需要与服务器建立一个TCP连接，服务器处理完成后立即断开TCP连接），无状态（服务端不记录客户端的登录状态）<br />http/1.1 默认支持长连接，支持只发送header信息，支持host域<br />http/2.0 多路复用，数据压缩（霍夫曼算法），支持服务器推送。

23. ** http请求都有哪些**

get、head、post、patch、options、connect

24. **打开一个网页，整个过程会使用哪些协议？**

![QQ截图20230705142957.png](https://cdn.nlark.com/yuque/0/2023/png/27308941/1688538791669-1e7422b3-a945-458a-b74a-3de837b859e8.png#averageHue=%23fafaf8&clientId=u77efe0b9-ab9e-4&from=drop&id=u41603dea&originHeight=545&originWidth=690&originalType=binary&ratio=1&rotation=0&showTitle=false&size=188869&status=done&style=none&taskId=ua55ab50d-4b71-44bf-9dac-3148db6a91c&title=)<br />总体来说分为以下几个过程:<br />1.DNS解析<br />2.TCP连接<br />3.SSL握手<br />4.发送HTTP请求<br />5.服务器处理请求并返回HTTP报文<br />6.浏览器解析渲染页面<br />7．连接结束

25. **DNS优化方式**

DNS（Domain Name System）优化是指通过一些技术手段提高 DNS 解析的性能和可靠性，以减少域名解析的延迟和提高访问速度<br />主要途径：DNS缓存、DNS负载均衡（让用户从最近的一个节点中获取IP地址）

26. **什么是ARP协议？**

ARP（Address Resolution Protocol）是一种用于将IP地址解析为MAC地址的协议。在局域网中，每个设备（主机或路由器）都有唯一的MAC地址和IP地址。当一个设备需要向另一个设备发送数据时，它需要知道目标设备的MAC地址才能正确发送数据帧。
# 操作系统

1. **进程与线程**

进程是指正在执行的一个程序的实例。每个进程都有独立的内存空间、程序计数器、寄存器等资源，它们之间相互隔离，互不影响。进程是操作系统分配资源和调度执行的基本单位，它可以包含多个线程。<br />线程是进程中的一个执行单元，也称为轻量级进程。一个进程可以包含多个线程，这些线程共享进程的资源，如内存空间、文件句柄等。线程可以独立执行，具有自己的程序计数器和栈，但是它们共享进程的其他资源。线程的创建、销毁和切换成本较低，可以实现更细粒度的并发控制。<br />进程与线程的主要区别如下：<br />（1）资源占用：每个进程都有独立的内存空间和系统资源，而线程共享进程的资源。<br />（2）切换开销：由于进程有独立的内存空间和资源，进程间切换的开销较大；而线程切换的开销相对较小。<br />（3）并发性：进程之间可以并发执行，彼此独立；而线程是在进程内部并发执行的，共享进程的上下文。

2. **进程状态切换（五种状态）**

![QQ截图20230705145608.png](https://cdn.nlark.com/yuque/0/2023/png/27308941/1688540200940-fa1ad9ad-8a4f-48a1-b827-f545c8fa3fcc.png#averageHue=%23fbf9f7&clientId=u77efe0b9-ab9e-4&from=drop&id=ub928279c&originHeight=427&originWidth=753&originalType=binary&ratio=1&rotation=0&showTitle=false&size=106646&status=done&style=none&taskId=u4607106a-e11d-497e-8362-030a7812055&title=)<br />（1）就绪状态（ready）:等待被调度<br />（2）运行状态(running）<br />（3）阻塞状态（等待状态）( waiting）:等待资源<br />进程的状态切换可以由以下几种事件触发：<br />（1）创建事件：当进程被创建时，从创建状态切换到就绪状态。<br />（2）调度事件：操作系统通过调度算法将就绪状态的进程分配给处理器，使其从就绪状态切换到运行状态。<br />（3）阻塞事件：当进程等待某个事件发生时，从运行状态切换到阻塞状态。<br />（4）就绪事件：当进程等待的事件发生后，从阻塞状态切换到就绪状态。<br />（5）终止事件：当进程执行完毕或出现错误时，从运行状态切换到终止状态。

3. **丧尸进程**

丧尸进程（Zombie Process）是一种特殊的进程状态，它处于终止状态（Terminated），但其父进程尚未对其进行完全清理的状态。当一个进程结束（终止）时，内核会向其父进程发送一个信号，通知父进程该子进程的终止状态。父进程需要调用适当的系统调用（如wait()或waitpid()）来获取子进程的终止状态并进行清理。如果父进程没有及时处理子进程的终止状态，子进程就会变成丧尸进程。

4. **进程调度算法**

（1）先来先服务（FCFS）。按照进程到达的顺序进行调度，先到达的进程先执行。<br />（2）最短作业优先（SJF）。选择执行时间最短的进程进行调度，以减少平均等待时间。<br />（3）优先级调度。每个进程都有一个优先级，优先级高的进程先执行。<br />（4）时间片轮转（Round Robin）。将CPU时间划分为固定大小的时间片，每个进程依次执行一个时间片，然后切换到下一个进程。<br />（5）多级反馈队列调度。将进程划分为多个队列，每个队列有不同的优先级和时间片大小，进程在队列之间进行切换。<br />（6）最短剩余时间优先（SRTF）。在SJF算法的基础上，动态地调整优先级，选择剩余执行时间最短的进程。<br />（7）多处理器调度。针对多处理器系统的调度算法，将进程合理地分配到不同的处理器上。

5. **进程间通信**

（1）管道（Pipe）。管道是一种半双工的通信方式，通过创建一个管道，在父进程和子进程之间传递数据<br />（2）消息队列（Message Queue）。消息队列是一种存放在内核中的消息链表，多个进程可以通过消息队列进行异步通信。<br />（3）共享内存（Shared Memory）。共享内存是一种最快的进程间通信方式，它允许多个进程共享同一块物理内存区域。<br />（4）信号量（Semaphore）。信号量是一种计数器，用于控制多个进程对共享资源的访问。<br />（5）信号（Signal）。信号是一种软件中断机制，用于通知进程发生了某种事件。<br />（6）套接字（Socket）。套接字是一种通过网络进行进程间通信的方式，可以在不同的主机之间进行通信。

6. **死锁**

死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。<br />必要条件：<br />(1 )互斥条件。一个资源每次只能被一个进程使用。<br />(2）占有和等待条件。一个进程因请求资源而阻塞时，对已获得的资源保持不放。<br />(3)不剥夺条件。进程已获得的资源，在末使用完之前，不能强行剥夺。<br />(4）循环等待条件。若干进程之间形成一种头尾相接的循环等待资源关系。<br />解决办法：<br />（1）预防死锁。通过破坏死锁产生的四个条件中的一个或多个，来预防死锁的发生。例如，采用资源有序分配、避免循环等待等策略。<br />（2）避免死锁。通过动态地进行资源分配和回收，根据当前系统状态判断是否会发生死锁，并做出相应的避免策略。<br />（3）检测与恢复。运行时检测系统是否发生死锁，若发生死锁，则采取相应的措施进行恢复，如终止某些进程、资源剥夺等。<br />（4）忽略死锁。某些情况下，忽略死锁并进行系统设计，仅在死锁发生时通过重启系统或手动干预来解决。

7. **内存管理**

在计算机系统中，内存被划分为多个连续的存储单元，每个存储单元都有唯一的地址。内存管理的任务是将进程所需的内存空间分配给其使用，并在进程结束后将已使用的内存空间释放，以便其他进程可以使用。<br />内存管理主要涉及以下几个方面：内存分配、内存映射、内存保护、内存回收、内存碎片整理。

8. **虚拟内存**

虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。

9. **页面置换算法**

在程序运行过程中，如果要访问的页面不在内存中，就发生缺页中断从而将该页调入内存中。此时<br />如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘对换区中来腾出空间。<br />主要的算法有：<br />（1）最佳替换算法（OPT）：选择离当前时间最长没有使用的页面进行置换。<br />（2）最近最久未使用算法（LRU）：根据页面最近的访问时间，选择最久未被访问的页面进行置换。<br />（3）最近未使用算法（NRU）：根据页面被访问的频率选择最少使用的页面进行置换。<br />（4）先进先出算法（FIFO）：按照页面调入物理内存的顺序进行置换。<br />（5）时钟算法（Clock）：使用一个类似时钟指针的数据结构来维护页面的访问情况。

10. **分段**

分段是一种内存管理技术，用于将程序的地址空间划分为若干个段，每个段代表不同的逻辑部分，例如代码段、数据段、堆栈段等。分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。

11. **操作系统为什么有用户态和内核态，用户级线程与内核级线程如何转换?**

操作系统中存在用户态和内核态的概念是为了实现对系统资源的保护和安全控制。用户态是指应用程序运行时的状态，应用程序只能访问有限的资源，并受到操作系统的限制和保护；而内核态是操作系统内核运行时的状态，具有更高的权限和对系统资源的直接访问能力。<br />用户态和内核态如何相互转换:<br />用户态切换到内核态的途径——>中断/异常、陷入（系统调用)<br />内核态切换到用户态的途径——>设置程序状态字（进程切换）当内核态程序完成其任务后，内核知道该将控制权交还给用户态程序。

12. **操作系统内核态负责的任务**

（1）管理系统资源<br />（2）处理中断和异常<br />（3）设备管理<br />（4）安全性和权限管理<br />等等
# Redis

1. **什么是Redis?**

Redis（Remote Dictionary Server）是一个开源的内存数据库管理系统，它被设计用作高性能、可扩展的键值存储和缓存解决方案。Redis具有以下特点：<br />（1）速度快。Redis将数据存储在内存中，以提供快速的读写操作。<br />（2）支持丰富数据类型。它支持多种数据类型，包括字符串、哈希、列表、集合和有序集合等。<br />（3）高性能。采用了基于事件驱动的异步I/O模型，可以处理大量的并发请求。<br />（4）分布式支持。R支持数据的分片存储和主从复制，可以将数据分布在多个节点上以实现高可用性和扩展性。<br />（5）支持丰富的功能。Redis提供了丰富的功能和操作，如事务支持、发布订阅机制、持久化、数据过期设置、原子操作等。<br />（6）多语言支持。Redis提供了多种语言的客户端库，可以方便地在不同的编程语言中使用Redis。

2. **Redis数据类型**

（1）String<br />（2）List<br />（3）set<br />（4）哈希字典<br />（5）有序set<br />（6）Redis-MIL等

![图片1.png](https://cdn.nlark.com/yuque/0/2023/png/27308941/1688545376708-a6f5cbf2-bd41-4d14-9e86-d1cfb208b99a.png#averageHue=%23212121&clientId=u77efe0b9-ab9e-4&from=drop&height=212&id=u730f961c&originHeight=846&originWidth=1904&originalType=binary&ratio=1&rotation=0&showTitle=false&size=47417&status=done&style=none&taskId=u9f80b622-74cf-405e-9cfa-8d225e40ade&title=&width=476)

3. **Redis基本数据类型底层结构**

（1）字符串（String）：字符串类型的值被存储在简单的动态字符串结构中。<br />（2）哈希（Hash）：哈希类型使用哈希表作为底层结构。<br />（3）列表（List）：列表类型使用双向链表作为底层结构。<br />（4）集合（Set）：集合类型使用哈希表作为底层结构。<br />（5）有序集合（Sorted Set）：有序集合类型底层使用跳跃表（Skip List）和哈希表结合的方式实现。<br />![QQ截图20230706155455.png](https://cdn.nlark.com/yuque/0/2023/png/27308941/1688630261812-2b0a7dc7-d419-4cd2-bed7-b75a965a51d4.png#averageHue=%23eeefdc&clientId=u413fa43a-d430-4&from=drop&id=u9e12c73d&originHeight=246&originWidth=807&originalType=binary&ratio=1&rotation=0&showTitle=false&size=122229&status=done&style=none&taskId=u005491f4-9c51-4a28-bd56-2e19a76fbb6&title=)

4. **跳跃表（Skip List)是如何做到有序性的？**

当需要查找或插入元素时，跳跃表从最上层的索引开始，根据节点的值进行比较，并根据节点之间的跳转关系逐层向下寻找，直到达到目标位置或者找到合适的插入位置。这种层次化的结构可以有效地减少比较次数，提高了查找和插入的效率，并保持了有序性。

5. **Redis持久化方式。（Redis如何保持持久化的？）**

Redis提供了两种主要的持久化方式：RDB（Redis Database）和AOF（Append-Only File）。<br />（1）RDB（快照）持久化：RDB持久化是通过将Redis在内存中的数据以快照的形式保存到磁盘上。当符合一定条件时，Redis会自动触发RDB持久化操作，将当前内存中的数据保存到一个二进制文件中。RDB文件是一个紧凑且高效的数据格式，适合用于备份和恢复数据。RDB持久化是默认开启的，可以通过配置文件或命令行参数来调整触发快照的条件和持久化的频率。<br />（2）AOF（日志）持久化：AOF持久化是通过将Redis的写操作以日志的方式追加到一个文件中来实现。每个写操作都以协议格式追加到AOF文件的末尾，以记录数据库的状态变化。在重启Redis时，可以通过重新执行AOF文件中的命令来还原数据库的状态。AOF持久化可以保证数据的实时持久化和完整性，但相对于RDB持久化会占用更多的磁盘空间和IO操作。可以通过配置文件或命令行参数来调整AOF持久化的策略，如追加方式、文件刷写频率等。

选择RDB还是AOF?<br />看需要，一般生成RDB文件需要比较久的时间，所以隔比较久的时间才备份一次，如果是几十分钟，那么到时候服务器崩溃了，就损失了这几十分钟的数据，如果是AOF则是每s进行备份，这个损失就很小，但是每次都需要将命令写入到磁盘会影响Redis 的性能。相比于AOF机制，如果数据集很大，RDB的启动效率会更高。所以可根据是否能接受几十分钟的数据损失，以及Redis 的性能受影响来决定选择持久化方式。<br />Redis本身的机制是AOF持久化开启且存在AOF文件时，优先加载AOF 文件；AOF关闭或者AOF文件不存在时，加载RDB文件；加载AOF/RDB文件后，Redis启动成功;AOF/RDB文件存在错误时，Redis启动失败并打印错误信息。

如果突然掉电会怎样？<br />取决于AOF日志sync属性的配置，如果不要求性能，在每条写指令时都 sync一下磁盘，就不会丢失数据。但是在高性能的要求下每次都sync是不现实的，一般都使用定时 sync，比如 1s1次，这个时候最多就会丢失1s的数据。

6. **RDB原理**

Redis会fork出一个子进程，负责将当前内存中的数据保存到磁盘上。在快照生成期间，主进程继续处理客户端请求，而子进程则负责将数据写入到临时文件中。子进程会将内存中的数据按照一定的格式写入到临时文件中，包括键值对的数据、过期时间等信息。当快照生成完成后，Redis会用新生成的快照文件替换掉原有的RDB文件，完成持久化过程。

7. **Redis如何保证缓存一致性**

（1）冷启动。在Redis启动或重启时，可以从持久化的数据源（如RDB文件或AOF日志）中恢复数据，确保缓存中的数据与持久化数据一致。<br />（2）数据同步。在使用Redis集群或主从复制时，可以使用复制机制来将主节点的数据同步到从节点，从而保持数据的一致性。<br />（3）读写分离。将读操作和写操作分离到不同的Redis节点上，读操作通过从节点进行，写操作通过主节点进行。<br />（4）双写策略。在写操作时，除了更新缓存之外，还更新数据源（如数据库）。这样可以保证数据源和缓存的一致性，但会增加写操作的复杂性和延迟。<br />（5）失效策略。根据业务需求和数据特性，选择合适的缓存失效策略，例如设置合理的过期时间、使用LRU（最近最少使用）算法等，以尽量减少数据不一致的可能性。

8. **什么是Redis缓存穿透、缓存击穿、缓存雪崩?**

缓存穿透（Cache Penetration）：指的是缓存中不存在所需数据，导致每次请求都穿过缓存层，直接查询数据库。这可能是由于恶意攻击、非法请求或者查询不存在的数据所导致。缓存穿透会给数据库造成压力，并且无法从缓存中获得性能提升。<br />缓存击穿（Cache Miss）：指的是一个热点数据在缓存中过期或被删除，此时有大量的请求同时访问该热点数据，导致所有请求都直接访问数据库。缓存击穿会导致数据库负载激增，性能下降。<br />缓存雪崩（Cache Avalanche）：指的是缓存中的大量数据同时过期，或者缓存服务不可用，导致所有请求都直接访问数据库。缓存雪崩通常是由于缓存服务器故障、网络问题、大规模数据更新等原因导致。缓存雪崩会导致数据库压力巨大，性能降低甚至宕机。

针对这些问题，可以采取以下措施进行缓解：<br />（1）缓存穿透：使用布隆过滤器（Bloom Filter）等技术，对请求进行过滤，避免非法或不存在的请求穿透到数据库。<br />（2）缓存击穿：在缓存失效前后加锁，防止多个请求同时访问数据库；或者使用热点数据永不过期策略，确保热点数据一直可用。<br />（3）缓存雪崩：设置合适的缓存过期时间，避免大量缓存同时过期；引入多级缓存，如本地缓存和分布式缓存，提高缓存的可用性；使用熔断机制，当缓存服务不可用时，及时降级或切换至备用方案。

9. **Redis哨兵模式（Sentinal）和集群模式（Cluster）的区别**

哨兵模式用于实现Redis的高可用性，通过监控和自动故障转移来保证Redis服务的可用性。在哨兵模式中，有一个主节点（Master）和多个从节点（Slave），哨兵节点（Sentinel）负责监控主节点和从节点的状态。当主节点宕机或不可用时，哨兵节点会自动选举一个从节点作为新的主节点，并将其他从节点切换到新的主节点服务下。<br />集群模式用于实现Redis的分布式架构，通过数据分片和数据复制来提供高可用性和高性能。在集群模式中，多个Redis节点组成一个集群，每个节点负责管理部分数据，同时对数据进行复制，实现数据的高可用性和负载均衡。集群模式支持水平扩展，可以动态地添加或移除节点，实现弹性和高可用的Redis服务。

10. **Redis集群如何实现**

假设刚开始有3个服务器节点，每个节点都是相互独立的，可以在节点1向节点2，节点3发送CLUSTER MEET<ip> <port>命令，让节点2和节点3加入到节点1所在的集群。

11. **Redis和Zookeeper实现分布式锁的区别**
12. **Redis常用命令**

SET key value  设置指定键的值<br />GET key 获取指定键的值<br />DEL key 删除指定键及其对应的值<br />EXISTS key 检查指定键是否存在<br />KEYS pattern 查找匹配指定模式的键

列表操作：<br />LPUSH key value 在列表的左侧添加一个或多个值。<br />RPUSH key value 在列表的右侧添加一个或多个值<br />LPOP key 从列表的左侧移除并返回第一个值<br />RPOP key 从列表的右侧移除并返回最后一个值<br />LRANGE key start stop  获取列表中指定范围的值

13. **Mysql和Redis的区别**

（1）Redis不支持事务回滚，即使事务中途执行出错，也会继续执行下去。<br />（2）Mysql是关系型数据库，只支持基本数据类型。Redis是非关系型数据库，支持丰富的数据类型。<br />（3）Mysql将数据存储在硬盘中，可以持久保存并在服务器重启后恢复数据，读取速度较慢。Redis可以选择使用持久化机制，可以将数据保存到硬盘上，也可以将数据保存在内存中。同时，Redis还可以用作缓存，只将部分数据存储在内存中，不保证持久性。

14. **Redis为什么快**

Redis将数据存储在内存中<br />单线程操作，避免了上下文切换。（Redis采用单线程的事件驱动模型，通过事件循环机制（它基于一个循环，不断地从事件队列中获取事件，并按照预定的方式处理这些事件）处理所有的客户端请求）<br />Redis使用非阻塞IO模型，通过IO多路复用技术（如epoll、kqueue）实现高效的网络通信

15. **Redis主从结构**

Redis主从结构是一种数据复制和高可用性的架构，其中一个Redis实例（主节点）负责处理所有写操作和部分读操作，而其他Redis实例（从节点）复制主节点的数据，并负责处理读操作。

16. **如何提升Redis的性能**

硬件性能<br />批量操作。将多个命令合并成一个批量操作或通过管道发送多个命令，可以减少网络延迟和负载。<br />根据实际需求和性能要求，合理配置持久化方式和参数。<br />根据实际情况调整Redis的配置参数，如最大内存限制、最大连接数、超时时间等。

17. **Redis的大key和热key问题**

![QQ截图20230706154522.png](https://cdn.nlark.com/yuque/0/2023/png/27308941/1688629542258-6b13ff38-6d7f-4a46-8298-be8c301b8e98.png#averageHue=%23dfdfdb&clientId=ub2b3dd1d-d21c-4&from=drop&id=u1fdf4e38&originHeight=578&originWidth=894&originalType=binary&ratio=1&rotation=0&showTitle=false&size=348851&status=done&style=none&taskId=ua2ebcc9c-c02c-4d35-8dd6-fefde040751&title=)<br />分片，分散压力<br />预加载<br />访问时间随机化

18. **Redis命名阻塞问题**

Redis命名阻塞问题是指当多个客户端同时尝试对同一个键进行写操作时，其中一个客户端的写操作可能会阻塞其他客户端的写操作，导致写操作的执行变慢。<br />为了解决Redis命名阻塞问题，可以采取以下几个策略：<br />（1）分片：将热点数据分散到多个Redis实例中，避免多个写操作集中在同一个实例上导致阻塞。<br />（2）异步操作：将耗时较长的写操作改为异步执行，使得写操作不会阻塞其他操作。例如，可以将写操作放入消息队列中由后台进程异步处理。<br />（3）提前拆分操作：如果知道某个键可能会被频繁写入，可以在写入前先拆分数据，将数据分散到多个键上，避免多个客户端同时写入同一个键。<br />（4）优化业务逻辑：从业务角度出发，优化写操作的频率和量，减少对同一个键的频繁写入。

19. **SDS和C语言字符串区别**

SDS（Simple Dynamic String）是Redis中用于存储字符串的一种数据结构，它是对C语言中的字符串类型的一种封装和扩展。<br />SDS具有以下特点：动态调整空间、二进制安全、支持字符串拼接等操作、兼容c语言字符串

20. **为什么Redis设计成单线程的？**

Redis是单线程，主要是指Redis 的网络IO和键值对读写是由一个线程来完成的，这也是 Redis对外提供键值存储服务的主要流程。但Redis 的其他功能，比如持久化、异步删除、集群数据同步等，其实是由额外的线程执行的。所以，严格来说，Redis并不是单线程。避免线程切换开销、线程安全性内存局部性、简化实现和维护。

21. **如何解决缓存和数据不一致问题？**

![QQ截图20230706192104.png](https://cdn.nlark.com/yuque/0/2023/png/27308941/1688642501525-1995221b-0986-467d-9022-aee327b6169f.png#averageHue=%23d4d49a&clientId=u5ede2180-01e6-4&from=drop&id=u7d1172ee&originHeight=152&originWidth=468&originalType=binary&ratio=1&rotation=0&showTitle=false&size=89489&status=done&style=none&taskId=uc7a67627-306a-4a2a-979c-4fd8ac5daca&title=)<br />重试机制

22. **Redis如何应对并发访问**

并发访问控制对应的操作主要是数据修改操作。当客户端需要修改数据时，基本流程分成两步:<br />（1）客户端先把数据读取到本地，在本地进行修改；<br />（2）客户端修改完数据后，再写回 Redis。<br />这个流程叫做“读取–修改–写回”操作(Read-Modify-Write，简称为 RMW操作)。当有多个客户端对同一份数据执行RMW操作的话，就需要让RMW操作涉及的代码以原子性方式执行。访问同一份数据的 RMW操作代码，就叫做临界区代码。为了保证数据并发修改的正确性，我们可以用锁把并行操作变成串行操作，串行操作就具有互斥性。一个客户端持有锁后，其他客户端只能等到锁释放，才能拿锁再进行修改。虽然加锁保证了互斥性，但是加锁也会导致系统并发性能降低。(lock 和 unlock命令）。
# MySQL

1. **什么是MySQL?**

MySQL是一种开源的关系型数据库管理系统（RDBMS），它是目前最流行和广泛使用的数据库之一。

2. **一条查询SQL是如何执行的？**

连接器:负责跟客户端建立连接、获取权限、维持和管理连接。<br />查询缓存:查询请求先访问缓存，命中直接返回。不推荐使用缓存，更新会把缓存清除(关闭缓存:参数query_cache_type设置成 DEMAND)。<br />分析器:对SQL语句做解析，判断sql是否正确。<br />优化器:决定使用哪个索引，多表关联( join）的时候，决定各个表的连接顺序。<br />执行器:执行语句，先判断用户有无查询权限，使用表定义的存储引擎。

![QQ截图20230706192932.png](https://cdn.nlark.com/yuque/0/2023/png/27308941/1688643228985-7fe3ef81-58aa-45f2-b306-75c46dbc3cc0.png#averageHue=%23e9eddf&clientId=u5ede2180-01e6-4&from=drop&id=u308c5b08&originHeight=398&originWidth=536&originalType=binary&ratio=1&rotation=0&showTitle=false&size=174718&status=done&style=none&taskId=uab51f51e-478a-423f-a420-fdb3f08c0c9&title=)<br />查询语句->语法解析->查询优化和执行计划生成->计划执行->结果返回

3. **一条更新SQL是如何执行的？**

查询语句->语法解析->查询重写->查询优化->锁定数据->数据更新->日志记录->提交事务->释放锁

语法解析：数据库管理系统（DBMS）首先对更新SQL进行语法解析，确保语法的正确性。<br />查询重写：DBMS将更新SQL转换为内部的查询结构，可能涉及到表之间的连接、过滤条件等。<br />查询优化：DBMS对查询进行优化，通过选择合适的索引、连接算法、查询计划等来提高查询性能。<br />锁定数据：对于需要更新的数据，DBMS会获取相应的行级锁或表级锁，以保证数据的一致性。<br />数据更新：DBMS执行实际的数据更新操作，根据更新SQL的要求修改相应的数据。<br />日志记录：DBMS将数据更新操作写入事务日志，以确保数据的持久性和事务的原子性。<br />提交事务：如果更新操作在一个事务中进行，DBMS会在所有更新操作执行成功后，将事务提交。提交事务将会持久地将更新操作的结果写入数据库。<br />释放锁：完成数据更新后，DBMS释放之前获取的锁定，允许其他事务继续操作相关数据。

4. **为什么MySQL不推荐使用缓存查询？**

查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。因此很可能你费劲地把结果存起来，还没使用呢，就被一个更新全清空了。对于更新压力大的数据库来说，查询缓存的命中率会非常低。除非你的业务就是有一张静态表，很长时间才会更新一次。比如，一个系统配置表，那这张表上的查询才适合使用查询缓存。MySQL8.0版本直接将查询缓存的整块功能删掉了。

5. **MySQL中的order by工作原理**

执行查询->数据准备->排序准备->数据填充->排序操作->排序结果返回<br />首先，MySQL会执行查询语句，获取符合查询条件的结果集。MySQL将查询结果存储在一个临时结果集中，并为每一行数据分配内存空间。MySQL为排序操作分配一块内存区域，称为排序缓冲区（sort buffer）。该缓冲区用于存储待排序的数据。MySQL将查询结果集中的数据逐一填充到排序缓冲区中。MySQL使用选择的排序算法对排序缓冲区中的数据进行排序。排序完成后，MySQL会将排序结果按照指定的顺序返回给客户端。

6. **MySQL的引擎用的哪一种，每种有什么区别？**

MySQL支持多种存储引擎，常见的引擎有InnoDB、MyISAM等。InnoDB是MySQL的默认存储引擎。<br />事务：InnoDB支持，MyISAM不支持<br />崩溃恢复：InnoDB支持，MyISAM不支持<br />外键：InnoDB支持，MyISAM不支持<br />通常情况下，InnoDB在性能和功能方面要优于MyISAM。场景中，MyISAM更适合select操作多的表（count计算更快），而InnoDB更适合insert 和 update多的表。

7. **为什么要索引？**

可以大大加快数据的检索速度（快速定位）<br />索引可以帮助数据库快速定位和访问存储在表中的数据，避免全表扫描的开销。通过索引，数据库可以直接跳过大量的数据，快速定位到符合查询条件的数据行，从而加快查询速度。同时可以将无序数据变为有序数据，配合低复杂度查找算法，可大大提高查找速度。

8. **什么是事务？**

事务（Transaction）是指由一组操作组成的一个执行单元，这组操作要么全部成功执行，要么全部失败回滚

9. **事务的特性(ACID)**

（1）原子性（Atomicity）：事务中的操作要么全部执行成功，要么全部执行失败回滚。如果任何一个操作失败，整个事务将回滚到事务开始前的状态，不会对数据库造成影响。<br />（2）一致性（Consistency）：事务的执行使数据库从一个一致状态转变为另一个一致状态。在事务开始之前和结束之后，数据库的约束条件、关联关系等都保持一致。<br />（3）隔离性（Isolation）：每个事务的执行都是独立的，相互之间不会相互干扰。事务在执行过程中对其他事务的操作是不可见的，以保证数据的一致性。<br />（4）持久性（Durability）：一旦事务提交成功，对数据库的修改将永久保存，即使发生系统故障或重启，修改的数据也不会丢失。

10. **什么是MVCC?**

MVCC（Multi-Version Concurrency Control）是一种并发控制机制，用于在数据库系统中实现并发访问和事务隔离。

11. **MySQL有哪些锁？**

行锁(InnoDB），表级锁(MyISAM，InnoDB），页面锁(BDB）。

12. **怎么防止sql注入**

sql注入是由于用户的输入未经充分检查，被编译成了代码被执行。所以从根本上防止上述类型攻击的手段，还是避免数据变成代码被执行，时刻分清代码和数据的界限。而具体到SQL注入来说，被执行的恶意代码是通过数据库的SQL解释引擎编译得到的，所以只要避免用户输入的数据被数据库系统编译就可以了。

13. **varchar和char的区别**

当使用VARCHAR存储字符串时，它是可变长度的，根据实际存储的字符长度占用空间，节省空间。而CHAR是固定长度的，始终占用指定长度的存储空间。VARCHAR不进行填充，而CHAR使用空格填充。在查询性能方面，CHAR较好，因为它的长度固定，无需额外解析长度信息。因此，VARCHAR适合存储长度可变的字符串，而CHAR适合存储长度固定的字符串。

14. **事务是如何回滚的？**

当事务回滚时，系统会根据事务的日志记录，逆序执行已经执行的操作的相反操作，将已经修改的数据页恢复到事务开始前的状态。通过逆序执行操作的相反操作，可以确保数据库的一致性和完整性。在回滚过程中，系统会释放由该事务持有的所有锁，以允许其他事务对相关数据进行操作。回滚操作也会生成相应的日志记录，用于记录事务回滚的相关信息，以便系统故障后可以根据日志进行恢复。
# MyBatis

1. **什么是MyBatis?**

MyBatis是一种持久层框架，用于将Java对象（POJO）与关系型数据库中的数据进行映射。它提供了简单且灵活的方式来访问和操作数据库，同时提供了一系列的映射工具和配置选项，使开发者能够更方便地编写数据库访问代码。

2. **MyBatis的优点**

（1）简单易用：MyBatis使用简单，学习曲线较低，开发者可以快速上手并编写数据库访问代码。它不需要开发者编写冗长的JDBC代码，而是提供了简洁的API和XML配置文件来定义SQL语句和映射关系。<br />（2）灵活性：MyBatis提供了灵活的SQL控制和参数映射机制。开发者可以编写原生的SQL语句，控制SQL的执行过程，并使用占位符或命名参数将Java对象映射到SQL中。这使得开发者能够更精确地控制数据库操作，并适应各种复杂的业务需求。<br />（3）高性能：MyBatis通过对SQL语句的优化和缓存的使用，提供了良好的性能。它支持一级缓存和二级缓存，可以减少数据库访问的次数，提高查询效率。此外，开发者还可以通过手动控制缓存的刷新和清除，进一步提升性能。<br />（4）易于集成：MyBatis可以与各种主流的Java框架和持久化技术集成，如Spring、Spring Boot、Spring MVC、Hibernate等。它提供了与这些框架的无缝集成支持，可以在不同的项目和环境中灵活使用。<br />（5）可扩展性：MyBatis支持开发者编写自定义的插件来扩展框架的功能。开发者可以通过插件来拦截和修改MyBatis的执行过程，实现自定义的功能和增强。这种可扩展性使得开发者可以根据自己的需求来定制和优化框架的行为。

3. **MyBatis的缺点**

（1）SQL语句的编写工作量较大，尤其当字段多、关联表多时，对开发人员编写SQL语句的功底有一定要求。<br />（2）SQL语句依赖于数据库，导致数据库移植性差，不能随意更换数据库。
# JPA

1. **什么是JPA?**

JPA（Java Persistence API）是Java EE规范中定义的一套用于对象持久化的API。JPA定义了一系列的接口和注解，用于描述实体类、定义数据库映射关系、执行CRUD操作等。通过使用JPA，开发人员可以使用面向对象的方式来操作数据库，而不必直接编写SQL语句。

# thymeleaf

1. **什么是thymeleaf**

Thymeleaf是一个Java模板引擎，用于在Web应用程序中实现动态页面的渲染。它可以与Spring框架无缝集成，并提供了丰富的功能和灵活的语法，使开发人员能够轻松地构建可视化和交互性强的Web界面。
# Docker

1. **什么是Docker?**

Docker是一种开源的容器化平台，用于构建、部署和运行应用程序。它基于容器化技术，可以将应用程序及其依赖项打包成一个独立的、可移植的容器，使应用程序可以在不同的环境中运行，而无需担心环境的差异性和依赖项的冲突。

2. **Docker和虚拟机的区别**

![image.png](https://cdn.nlark.com/yuque/0/2023/png/27308941/1688974952261-7a803311-d296-41c0-ba3b-9fcb4b3818bc.png#averageHue=%23fdfefe&clientId=ubbdfb1bd-3895-4&from=paste&height=354&id=u1ee91daa&originHeight=354&originWidth=602&originalType=binary&ratio=1&rotation=0&showTitle=false&size=39674&status=done&style=none&taskId=uc1e9e090-e81d-48db-9e4b-034f81d9fa2&title=&width=602)<br />虚拟机通过在物理硬件上模拟完整的操作系统和硬件环境来运行应用程序，每个虚拟机都有自己的操作系统和资源管理，启动时间更长。而Docker使用容器来运行应用程序，容器共享主机操作系统的内核，可以更高效地利用系统资源，启动更加迅速。另一方面，虚拟机提供了完全的隔离性，每个虚拟机都有独立的文件系统、网络栈和进程空间。而Docker容器通过命名空间和控制组等Linux内核特性来实现隔离，容器之间共享主机操作系统的内核，提供了较弱的隔离性。<br />总的来说，虚拟机提供了更高的隔离性和安全性，适合运行不同的操作系统和应用程序。而Docker容器提供了更高的性能和资源利用率，适合构建和部署轻量级的应用程序。

3. **Docker容器有多少种状态**

运行、暂停、重启、退出

4. **Docker核心组件**

（1）Docker引擎（Docker Engine）。Docker引擎是Docker的核心技术，负责管理和运行容器。<br />（2）Docker镜像（Docker Images）。镜像是Docker应用程序的打包和分发单位。<br />（3）Docker容器（Docker Containers）。容器是从镜像创建的运行实例，它是一个独立的、隔离的执行环境。<br />（4）Docker注册中心（Docker Registry）。注册中心是用于存储和分享Docker镜像的中央仓库。<br />（5）Docker Compose。Docker Compose是一个用于定义和管理多个Docker容器的工具。

5. **如何实现Docker的自动化部署？**

Docker可以通过使用自动化部署工具，例如Docker Compose、Docker Swarm、Kubernetes和AWS Elastic Beanstalk等。这些工具可以快速、简单和可控的部署和管理多个Docker容器的编排。

6. **Docker的常用操作**

docker run<br />docker attach<br />docker exec<br />docker stop $(docker ps -aq)<br />docker rm $(docker ps -aq)
# K8s

1. **什么是K8s?**

Kubernetes（通常简称为K8s）是一个开源的容器编排平台，用于自动化部署、扩展和管理容器化应用程序。它提供了一套强大的工具和机制，使开发人员能够方便地部署和管理分布式应用程序。
# 消息队列

1. **什么是消息队列**

消息队列是一种在分布式系统中用于消息传递的通信模型。在消息队列中，发送者将消息发布到队列中，而接收者则从队列中订阅和接收消息。消息队列作为中间件，扮演了解耦、异步和缓冲的角色，提供了可靠的消息传递机制。发送者和接收者之间不需要直接耦合，它们只需要知道如何发送和接收消息，并通过消息队列来进行通信。使用较多的消息队列有ActiveMQ，RabbitMQ，Kafka，RocketMQ。

2. **为什么要使用消息队列**

1.通过异步处理提高系统性能(削峰、减少响应所需时间)<br />2.降低系统耦合性。
# 数据结构与算法
树的遍历：先序，中序，后序，层序等

**一：阿里技术一面（基础掌握牢固）**<br />jvm<br />海量数据处理

- 常用的异常类型?
- session
- java锁
- gc原理
- hashmap
- listlink arraylist 区别
- aop 原理
- 多线程
- kafka 原理和容错
- spark hadoop 原理
- redis 同步机制
- classLoader 机制
- Http 协议
- cookie的限制
- 如何设计一个分步式登录系统？
- Spring加载过程？
- 自己有没有写过类似Spring这样的AOP事务？
- spring的加载过程？
- atomic 与 volatile的区别？
- Thread的 notify（）给notifyAll（）的区别?
- notifiy（）是唤醒的那一个线程?
- Thread.sleep（）唤醒以后是否需要重新竞争？
- 单例有多少种写法? 有什么区别? 你常用哪一种单例，为什么用这种？
- 问一个Thread.join（）相关的问题?
- 写一个JAVA死锁的列子?
- 如何解决死锁?
- GC回收算法,及实现原理?
- HashMap数据存储结构? key重复了怎么办? 是如何解决的?
- Spring AOP的实现原理，底层用什么实现的？

**阿里技术二面（技术原理、个人擅长的项目）**<br />重点是面试技术原理，以及对技术的热情和专研程度：

- Java的高级知识
- 开源框架的原理
- JVM
- 多线程
- 高并发
- 中间件
- 之前项目经历，运用的技术，遇到的问题，如何解决，个人有什么收获和成长；
- 对于技术的热情（平时是否看些技术书籍，逛论坛，写博客，写源代码或程序等）；

**JAVA开发技术面试可能问到的问题？

**

- 我们主要考核的是网络nio 分布式数据库高并发大数据
- 自定义表格的实现?
- 动态表单设计?
- in-jvm（必考）以及jmm缓存模型如何调优?
- 常用的RPC框架
- nio和io
- 并发编程，设计模式
- 地图组件?
- hashmap有什么漏洞会导致他变慢？
- 如何给hashmap的key对象设计他的hashcode？
- 泛型通配符?在什么情况下使用？
- 后端方面：redis?分布式框架dubbo（阿里巴巴开源框架）?设计模式?
- 场景式的问题:秒杀,能列出常见的排队、验证码、库存扣减方式对系统高并发的影响?
- 能根据实际的需要构建缓存结构提高提高网站的访问速度，熟练使用ehcache、oscache，了解memcache。
- 了解基于dns轮询的负载均衡，熟练配置web服务器实现负载均衡，程序级能综合使用基于hash或取模等手段实现软负载。
- 熟悉分布式数据库设计和优化技术，熟练使用mysql、oracle、SqlServer等主流数据库，熟悉hadoop hbase mangodb redis ehcache、oscache memcache。对于大数据量的数据库处理采用分表分库、数据库读写分离、建立缓存等手段优化性能。
- 熟练掌握lucene，能基于lucene开发大型的搜索引擎，并能用lucene来改善和优化数据库的like查询。

**项目部分**

- 缓存的使用，如果现在需要实现一个简单的缓存，供搜索框中的ajax异步请求调用，使用什么结构？
- 内存中的缓存不能一直存在，用什么算法定期将搜索权重较低的entry去掉？
- TCP如何保证安全性
- 红黑树的问题，B+数
- JDK1.8中对HashMap的增强，如果一个桶上的节点数量过多，链表+数组的结构就会转换为红黑树。
- 项目中使用的单机服务器，如果将它部署成分布式服务器？
- MySQL的常见优化方式、定为慢查询
- 手写一个线程安全的单例模式

**进阿里必会知识：

**

- 算法和数据结构数组、链表、二叉树、队列、栈的各种操作（性能，场景）
- 二分查找和各种变种的二分查找
- 各类排序算法以及复杂度分析（快排、归并、堆）
- 各类算法题（手写）
- 理解并可以分析时间和空间复杂度。
- 动态规划（笔试回回有。。）、贪心。
- 红黑树、AVL树、Hash树、Tire树、B树、B+树。
- 图算法（比较少，也就两个最短路径算法理解吧）
- 计算机网络OSI7层模型（TCP4层）每层的协议
- get/post 以及幂等性
- http 协议头相关
- 网络攻击（CSRF、XSS）
- TCP/IP三次握手、四次挥手
- TCP与UDP比较
- DDos攻击
- （B）IO/NIO/AIO三者原理，各个语言是怎么实现的
- Netty
- Linux内核select poll epoll
- 数据库（最多的还是mysql，Nosql有redis）索引（包括分类及优化方式，失效条件，底层结构）
- sql语法（join，union，子查询，having，group by）
- 引擎对比（InnoDB，MyISAM）
- 数据库的锁（行锁，表锁，页级锁，意向锁，读锁，写锁，悲观锁，乐观锁，以及加锁的select sql方式）
- 隔离级别，依次解决的问题（脏读、不可重复读、幻读）
- 事务的ACID
- B树、B+树
- 优化（explain，慢查询，show profile）
- 数据库的范式
- 分库分表，主从复制，读写分离。
- Nosql相关（redis和memcached区别之类的，如果你熟悉redis，redis还有一堆要问的）
- 操作系统：进程通信IPC（几种方式），与线程区别
- OS的几种策略（页面置换，进程调度等，每个里面有几种算法）
- 互斥与死锁相关的
- linux常用命令（问的时候都会给具体某一个场景）
- Linux内核相关（select、poll、epoll）
- 编程语言（这里只说Java）：把我之后的面经过一遍，Java感觉覆盖的就差不多了，不过下面还是分个类。
- Java基础（面向对象、四个特性、重载重写、static和final等等很多东西）
- 集合（HashMap、ConcurrentHashMap、各种List，最好结合源码看）
- 并发和多线程（线程池、SYNC和Lock锁机制、线程通信、volatile、ThreadLocal、CyclicBarrier、Atom包、CountDownLatch、AQS、CAS原理等等）
- JVM（内存模型、GC垃圾回收，包括分代，GC算法，收集器、类加载和双亲委派、JVM调优，内存泄漏和内存溢出）
- IO/NIO相关
- 反射和代理、异常、Java8相关、序列化
- 设计模式（常用的，jdk中有的）
- Web相关（servlet、cookie/session、Spring）

**阿里面试题目范畴：**

- 内存模型
- 类加载机制
- GC
- JVM调优
- 线程池原理
- 动态代理
- 悲观锁乐观锁
- 高并发问题
- 事务隔离级别
- 索引原理
- 限流
- 分库分表
- 分布式事务提交
- 微服务
- dubbo原理

**阿里面试总结**<br />阿里比较喜欢的人才特点：对技术有热情，强硬的技术基础实力；主动，善于团队协作，善于总结思考。<br />技术基础以及的问题多看看书准备，不懂的直接说不懂没关系的；在项目细节上多把关一下，根据项目有针对性的谈自己的技术亮点，能表达清楚，可以引导面试官来问你比较擅长的技术问题。


[https://www.jb51.net/it/744214.html](https://www.jb51.net/it/744214.html)
